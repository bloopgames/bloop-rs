//! This crate will eventually be autogenerated (see
//! <https://github.com/bloopgames/bloop/issues/13>). It contains Rust
//! bindings for the `animation` package. Rust modules using `animation` should
//! depend on this crate, not the `animation` crate.

use std::{
    mem::{MaybeUninit, transmute},
    num::NonZero,
};

use engine::{
    FfiStr,
    prelude::*,
    snapshot::{Deserialize, Serialize},
};

use crate::ffi::*;
pub use crate::ffi::{load_module_proc_addrs, set_ecs_type_id};

mod ffi;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u32)]
pub enum Error {
    InvalidSpriteAnimationId = 1,
    SpriteAnimationNotFound,
    SpriteAnimationNotLoaded,
    SpriteAnimationTagNotFound,
    MAX,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Deserialize, Serialize)]
#[repr(transparent)]
pub struct SpriteAnimationId(NonZero<u32>);

pub struct SpriteAnimations;

impl SpriteAnimations {
    pub fn load_aseprite_animation(
        this: &mut Mut<'_, Self>,
        engine: &Engine,
        path: &str,
    ) -> SpriteAnimationId {
        #[cfg(not(feature = "dynamic_wasm"))]
        unsafe {
            SPRITE_ANIMATIONS_LOAD_ASEPRITE_ANIMATION.unwrap_unchecked()(
                engine,
                this.ecs_storage_ptr().as_ptr(),
                &FfiStr::new(path),
            )
        }

        #[cfg(feature = "dynamic_wasm")]
        unsafe {
            engine::wasm::alloc_and_write_external_slice(path.as_bytes(), |path_ptr| {
                let ffi_str = FfiStr::from_raw_parts(path_ptr, path.len());

                engine::wasm::alloc_and_write_external(&ffi_str, |ffi_str_ptr| {
                    SPRITE_ANIMATIONS_LOAD_ASEPRITE_ANIMATION.unwrap_unchecked()(
                        engine,
                        this.ecs_storage_ptr().as_ptr(),
                        ffi_str_ptr,
                    )
                })
            })
        }
    }

    pub fn load_custom_animation(
        this: &mut Mut<'_, Self>,
        frames: EcsVec<SpriteAnimationFrame>,
        tags: EcsVec<SpriteAnimationTag>,
    ) -> SpriteAnimationId {
        let (frames_backing_store, frames_len) = frames.into_raw_parts();
        let (tags_backing_store, tags_len) = tags.into_raw_parts();

        unsafe {
            SPRITE_ANIMATIONS_LOAD_CUSTOM_ANIMATION.unwrap_unchecked()(
                this.ecs_storage_ptr().as_ptr(),
                frames_backing_store,
                frames_len,
                tags_backing_store,
                tags_len,
            )
        }
    }

    pub fn get(&self, id: SpriteAnimationId) -> Option<Ref<'_, SpriteAnimationAssetState>> {
        unsafe { SPRITE_ANIMATIONS_GET.unwrap_unchecked()(self, id).map(|ptr| Ref::new(ptr)) }
    }

    /// Sets the active tag for the given sprite animation. If the tag is
    /// already active, nothing will be modified (i.e. the animation will not
    /// restart).
    ///
    /// This does not automatically play the animation if `animation.playing ==
    /// false`, `play()` should be called separately.
    pub fn set_animation_tag(
        &self,
        animation: &mut Mut<'_, SpriteAnimation>,
        tag: &str,
    ) -> Result<(), Error> {
        #[cfg(not(feature = "dynamic_wasm"))]
        let res = unsafe {
            SPRITE_ANIMATIONS_SET_ANIMATION_TAG.unwrap_unchecked()(
                self as *const Self,
                animation.ecs_storage_ptr().as_ptr(),
                &FfiStr::new(tag),
            )
        };

        #[cfg(feature = "dynamic_wasm")]
        let res = unsafe {
            engine::wasm::update_external_mut(animation, |animation| {
                engine::wasm::alloc_and_write_external_slice(tag.as_bytes(), |tag_ptr| {
                    let ffi_str = FfiStr::from_raw_parts(tag_ptr, tag.len());

                    engine::wasm::alloc_and_write_external(&ffi_str, |ffi_str_ptr| {
                        SPRITE_ANIMATIONS_SET_ANIMATION_TAG.unwrap_unchecked()(
                            self as *const Self,
                            animation.as_ptr(),
                            ffi_str_ptr,
                        )
                    })
                })
            })
        };

        if let Some(res) = res {
            assert!(res.get() < Error::MAX as u32);
            Err(unsafe { transmute::<u32, Error>(res.get()) })
        } else {
            Ok(())
        }
    }
}

/// This enum is used to track the state of a sprite animation. When a sprite
/// animation is first loaded, a sprite animation will be `Loading`. Once the
/// asset loads, it will be set to `Loaded` (or `Invalid` if the asset failed to
/// load).
#[derive(Debug, Serialize, Deserialize)]
#[repr(u8)]
pub enum SpriteAnimationAssetState {
    Loaded(SpriteAnimationInfo),
    Loading { path: EcsString },
    Invalid { reason: EcsString },
}

#[derive(Debug, Serialize, Deserialize)]
#[repr(C)]
pub struct SpriteAnimationInfo {
    /// The ID of this sprite animation.
    pub sprite_animation_id: SpriteAnimationId,
    /// Information about each frame in this animation.
    pub frames: EcsVec<SpriteAnimationFrame>,
    /// This works like Aseprite tags. If there are no tags, this will be empty.
    pub tags: EcsVec<SpriteAnimationTag>,
}

#[derive(Debug)]
#[repr(C)]
pub struct SpriteAnimationFrame {
    /// The ID of the sprite sheet texture backing this animation.
    pub texture_id: Option<TextureId>,
    /// The size of the frame, in pixels.
    pub size: Vec2,
    /// The normalized UV region of this frame in the texture.
    pub uv_region: Rect,
    /// The duration of the frame in seconds.
    pub duration: f32,
}

#[derive(Debug)]
#[repr(C)]
pub struct SpriteAnimationTag {
    pub name: EcsString,
    pub start_frame: u32,
    pub end_frame: u32,
    pub direction: PlaybackDirection,
}

#[derive(Clone, Copy, Debug, Default)]
#[repr(u8)]
pub enum PlaybackDirection {
    #[default]
    Forward,
    Reverse,
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct SpriteAnimation {
    pub sprite_animation_id: Option<SpriteAnimationId>,
    pub tag_index: u32,
    pub playing: bool,
    /// A multiplier applied to the animation playback rate.
    pub rate_scale: f32,
    pub looping: bool,
    /// If `Some`, this will override the animation's playback direction.
    pub playback_direction_override: EcsOption<PlaybackDirection>,

    frame_time: f32,
    current_frame: u32,
}

impl Default for SpriteAnimation {
    fn default() -> Self {
        Self {
            sprite_animation_id: None,
            tag_index: 0,
            playing: true,
            rate_scale: 1.,
            looping: true,
            playback_direction_override: EcsOption::None,
            frame_time: 0.,
            current_frame: 0,
        }
    }
}

impl SpriteAnimation {
    pub fn new(sprite_animation_id: SpriteAnimationId) -> Self {
        let mut ret = MaybeUninit::uninit();

        #[cfg(not(feature = "dynamic_wasm"))]
        unsafe {
            SPRITE_ANIMATION_NEW.unwrap_unchecked()(sprite_animation_id, &mut ret);
        }

        #[cfg(feature = "dynamic_wasm")]
        unsafe {
            engine::wasm::alloc_uninit_and_read_external(&mut ret, |ret| {
                SPRITE_ANIMATION_NEW.unwrap_unchecked()(sprite_animation_id, ret);
            });
        }

        unsafe { ret.assume_init() }
    }

    pub fn play(this: &mut Mut<'_, Self>) {
        #[cfg(not(feature = "dynamic_wasm"))]
        unsafe {
            SPRITE_ANIMATION_PLAY.unwrap_unchecked()(this.ecs_storage_ptr());
        }

        #[cfg(feature = "dynamic_wasm")]
        unsafe {
            engine::wasm::update_external_mut(this, |this| {
                SPRITE_ANIMATION_PLAY.unwrap_unchecked()(this);
            });
        }
    }

    pub fn pause(this: &mut Mut<'_, Self>) {
        #[cfg(not(feature = "dynamic_wasm"))]
        unsafe {
            SPRITE_ANIMATION_PAUSE.unwrap_unchecked()(this.ecs_storage_ptr());
        }

        #[cfg(feature = "dynamic_wasm")]
        unsafe {
            engine::wasm::update_external_mut(this, |this| {
                SPRITE_ANIMATION_PAUSE.unwrap_unchecked()(this);
            });
        }
    }

    /// Sets the active animation. This does not automatically play the
    /// animation if `playing == false`, `play()` should be called separately.
    pub fn set_active_animation(this: &mut Mut<'_, Self>, animation_id: SpriteAnimationId) {
        #[cfg(not(feature = "dynamic_wasm"))]
        unsafe {
            SPRITE_ANIMATION_SET_ACTIVE_ANIMATION.unwrap_unchecked()(
                this.ecs_storage_ptr(),
                animation_id,
            );
        }

        #[cfg(feature = "dynamic_wasm")]
        unsafe {
            engine::wasm::update_external_mut(this, |this| {
                SPRITE_ANIMATION_SET_ACTIVE_ANIMATION.unwrap_unchecked()(this, animation_id);
            });
        }
    }
}
