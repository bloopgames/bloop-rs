//! This crate will eventually be autogenerated (see
//! <https://github.com/bloopgames/bloop/issues/13>). It contains Rust
//! bindings for the `physics` package. Rust modules using `physics` should
//! depend on this crate, not the `physics` crate.

use std::{
    ffi::c_void,
    mem::{MaybeUninit, transmute},
    ptr::NonNull,
};

use engine::prelude::*;

#[derive(Clone, Copy, Debug, PartialEq)]
#[repr(C)]
pub enum Collider {
    Sphere {
        radius: f32,
    },
    Box {
        size: Vec2,
    },
    Capsule {
        /// The distance between the center of each sphere.
        height: f32,
        /// The radius of the spheres which make up the ends of the capsule.
        radius: f32,
    },
}

static mut COLLIDER_CID: Option<EcsTypeId> = None;

impl EcsType for Collider {
    fn id() -> EcsTypeId {
        unsafe { COLLIDER_CID.expect("ComponentId unassigned") }
    }

    unsafe fn set_id(id: EcsTypeId) {
        unsafe {
            COLLIDER_CID = Some(id);
        }
    }

    fn string_id() -> &'static str {
        "physics::Collider"
    }

    fn null_terminated_string_id() -> &'static str {
        concat!("physics::Collider", '\0')
    }
}

impl Component for Collider {}

#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct ColliderDebugRender {
    pub color: Color,

    /// If present, this will override the depth of the entity's `Transform`.
    pub depth: Option<f32>,
}

impl Default for ColliderDebugRender {
    fn default() -> Self {
        Self {
            color: Color::MAGENTA,
            depth: None,
        }
    }
}

static mut COLLIDER_DEBUG_RENDER_CID: Option<EcsTypeId> = None;

impl EcsType for ColliderDebugRender {
    fn id() -> EcsTypeId {
        unsafe { COLLIDER_DEBUG_RENDER_CID.expect("ComponentId unassigned") }
    }

    unsafe fn set_id(id: EcsTypeId) {
        unsafe {
            COLLIDER_DEBUG_RENDER_CID = Some(id);
        }
    }

    fn string_id() -> &'static str {
        "physics::ColliderDebugRender"
    }

    fn null_terminated_string_id() -> &'static str {
        concat!("physics::ColliderDebugRender", '\0')
    }
}

impl Component for ColliderDebugRender {}

#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub enum ClosestPoints {
    /// The two objects are intersecting.
    Intersecting,
    /// The two objects are non-intersecting but closer than a given
    /// user-defined distance.
    WithinMargin { a: Vec2, b: Vec2 },
    /// The two objects are non-intersecting and further than a given
    /// user-defined distance.
    Disjoint,
}

/// Computes the pair of closest points between two shapes.
///
/// Returns `ClosestPoints::Disjoint` if the objects are separated by a distance
/// greater than `max_dist`. The result points in `ClosestPoints::WithinMargin`
/// are expressed in world-space.
pub fn closest_points(
    collider_a: &Collider,
    local_to_world_a: &LocalToWorld,
    collider_b: &Collider,
    local_to_world_b: &LocalToWorld,
    max_dist: f32,
) -> ClosestPoints {
    let mut ret = MaybeUninit::<ClosestPoints>::uninit();

    #[cfg(not(feature = "dynamic_wasm"))]
    unsafe {
        CLOSEST_POINTS.unwrap_unchecked()(
            collider_a,
            local_to_world_a,
            collider_b,
            local_to_world_b,
            max_dist,
            &mut ret,
        );
    }

    #[cfg(feature = "dynamic_wasm")]
    unsafe {
        #[derive(Copy, Clone, Debug)]
        struct Params {
            collider_a: Collider,
            local_to_world_a: LocalToWorld,
            collider_b: Collider,
            local_to_world_b: LocalToWorld,
        }

        let params = Params {
            collider_a: *collider_a,
            local_to_world_a: *local_to_world_a,
            collider_b: *collider_b,
            local_to_world_b: *local_to_world_b,
        };

        engine::wasm::alloc_write_and_read_external(params, &mut ret, |params, ret| {
            let params = params.cast::<u8>();

            CLOSEST_POINTS.unwrap_unchecked()(
                params.add(std::mem::offset_of!(Params, collider_a)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_a))
                    .cast(),
                params.add(std::mem::offset_of!(Params, collider_b)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_b))
                    .cast(),
                max_dist,
                ret,
            )
        })
    };

    unsafe { ret.assume_init() }
}

static mut CLOSEST_POINTS: Option<
    unsafe extern "C" fn(
        *const Collider,
        *const LocalToWorld,
        *const Collider,
        *const LocalToWorld,
        f32,
        *mut MaybeUninit<ClosestPoints>,
    ),
> = None;

/// Computes the minimum distance separating two shapes.
///
/// Returns `0.0` if the objects are touching or penetrating.
pub fn distance(
    collider_a: &Collider,
    local_to_world_a: &LocalToWorld,
    collider_b: &Collider,
    local_to_world_b: &LocalToWorld,
) -> f32 {
    #[cfg(not(feature = "dynamic_wasm"))]
    unsafe {
        DISTANCE.unwrap_unchecked()(collider_a, local_to_world_a, collider_b, local_to_world_b)
    }

    #[cfg(feature = "dynamic_wasm")]
    unsafe {
        #[derive(Copy, Clone, Debug)]
        struct Params {
            collider_a: Collider,
            local_to_world_a: LocalToWorld,
            collider_b: Collider,
            local_to_world_b: LocalToWorld,
        }

        let params = Params {
            collider_a: *collider_a,
            local_to_world_a: *local_to_world_a,
            collider_b: *collider_b,
            local_to_world_b: *local_to_world_b,
        };

        engine::wasm::alloc_and_write_external(&params, |params| {
            let params = params.cast::<u8>();

            DISTANCE.unwrap_unchecked()(
                params.add(std::mem::offset_of!(Params, collider_a)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_a))
                    .cast(),
                params.add(std::mem::offset_of!(Params, collider_b)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_b))
                    .cast(),
            )
        })
    }
}

static mut DISTANCE: Option<
    unsafe extern "C" fn(
        *const Collider,
        *const LocalToWorld,
        *const Collider,
        *const LocalToWorld,
    ) -> f32,
> = None;

#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct Contact {
    pub point_a: Vec2,
    pub point_b: Vec2,
    pub normal_a: Vec2,
    pub normal_b: Vec2,
    pub dist: f32,
}

/// Computes one pair of contact points point between two shapes.
///
/// Returns `None` if the objects are separated by a distance greater than
/// `prediction`. The result is given in world-space.
pub fn contact(
    collider_a: &Collider,
    local_to_world_a: &LocalToWorld,
    collider_b: &Collider,
    local_to_world_b: &LocalToWorld,
    prediction: f32,
) -> Option<Contact> {
    let mut ret = MaybeUninit::uninit();

    #[cfg(not(feature = "dynamic_wasm"))]
    let res = unsafe {
        CONTACT.unwrap_unchecked()(
            collider_a,
            local_to_world_a,
            collider_b,
            local_to_world_b,
            prediction,
            &mut ret,
        )
    };

    #[cfg(feature = "dynamic_wasm")]
    let res = unsafe {
        #[derive(Copy, Clone, Debug)]
        struct Params {
            collider_a: Collider,
            local_to_world_a: LocalToWorld,
            collider_b: Collider,
            local_to_world_b: LocalToWorld,
        }

        let params = Params {
            collider_a: *collider_a,
            local_to_world_a: *local_to_world_a,
            collider_b: *collider_b,
            local_to_world_b: *local_to_world_b,
        };

        engine::wasm::alloc_write_and_read_external(params, &mut ret, |params, ret| {
            let params = params.cast::<u8>();

            CONTACT.unwrap_unchecked()(
                params.add(std::mem::offset_of!(Params, collider_a)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_a))
                    .cast(),
                params.add(std::mem::offset_of!(Params, collider_b)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_b))
                    .cast(),
                prediction,
                ret,
            )
        })
    };

    if res {
        Some(unsafe { ret.assume_init() })
    } else {
        None
    }
}

static mut CONTACT: Option<
    unsafe extern "C" fn(
        *const Collider,
        *const LocalToWorld,
        *const Collider,
        *const LocalToWorld,
        f32,
        *mut MaybeUninit<Contact>,
    ) -> bool,
> = None;

/// Tests whether two shapes are intersecting.
pub fn intersection_test(
    collider_a: &Collider,
    local_to_world_a: &LocalToWorld,
    collider_b: &Collider,
    local_to_world_b: &LocalToWorld,
) -> bool {
    #[cfg(not(feature = "dynamic_wasm"))]
    unsafe {
        INTERSECTION_TEST.unwrap_unchecked()(
            collider_a,
            local_to_world_a,
            collider_b,
            local_to_world_b,
        )
    }

    #[cfg(feature = "dynamic_wasm")]
    unsafe {
        #[derive(Copy, Clone)]
        struct Params {
            collider_a: Collider,
            local_to_world_a: LocalToWorld,
            collider_b: Collider,
            local_to_world_b: LocalToWorld,
        }

        let params = Params {
            collider_a: *collider_a,
            local_to_world_a: *local_to_world_a,
            collider_b: *collider_b,
            local_to_world_b: *local_to_world_b,
        };

        engine::wasm::alloc_and_write_external(&params, |params| {
            let params = params.cast::<u8>();

            INTERSECTION_TEST.unwrap_unchecked()(
                params.add(std::mem::offset_of!(Params, collider_a)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_a))
                    .cast(),
                params.add(std::mem::offset_of!(Params, collider_b)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_b))
                    .cast(),
            )
        })
    }
}

static mut INTERSECTION_TEST: Option<
    unsafe extern "C" fn(
        *const Collider,
        *const LocalToWorld,
        *const Collider,
        *const LocalToWorld,
    ) -> bool,
> = None;

/// Configuration for controlling the behavior of time-of-impact (i.e. shape-casting) calculations.
#[derive(Copy, Clone, Debug, PartialEq)]
#[repr(C)]
pub struct ShapeCastOptions {
    /// The maximum time-of-impacts that can be computed.
    ///
    /// Any impact occurring after this time will be ignored.
    pub max_time_of_impact: f32,
    /// The shapes will be considered as impacting as soon as their distance is smaller or
    /// equal to this target distance. Must be positive or zero.
    ///
    /// If the shapes are separated by a distance smaller than `target_distance` at time 0, the
    /// calculated witness points and normals are only reliable if
    /// [`Self::compute_impact_geometry_on_penetration`] is set to `true`.
    pub target_distance: f32,
    /// If `false`, the time-of-impact algorithm will automatically discard any impact at time
    /// 0 where the velocity is separating (i.e., the relative velocity is such that the distance
    /// between the objects projected on the impact normal is increasing through time).
    pub stop_at_penetration: bool,
    /// If `true`, witness points and normals will be calculated even when the time-of-impact is 0.
    pub compute_impact_geometry_on_penetration: bool,
}

impl Default for ShapeCastOptions {
    fn default() -> Self {
        Self {
            max_time_of_impact: f32::MAX,
            target_distance: 0.,
            stop_at_penetration: true,
            compute_impact_geometry_on_penetration: true,
        }
    }
}

#[derive(Clone, Copy, Debug)]
#[repr(C)]
pub struct ShapeCastHit {
    /// The time at which the objects touch.
    pub time_of_impact: f32,

    /// The local-space closest point on the first shape at the time of impact.
    ///
    /// This value is unreliable if `status` is
    /// [`ShapeCastStatus::PenetratingOrWithinTargetDist`] and
    /// [`ShapeCastOptions::compute_impact_geometry_on_penetration`] was set to
    /// `false`.
    pub witness_a: Vec2,

    /// The local-space closest point on the second shape at the time of impact.
    ///
    /// This value is unreliable if `status` is
    /// [`ShapeCastStatus::PenetratingOrWithinTargetDist`] and both
    /// [`ShapeCastOptions::compute_impact_geometry_on_penetration`] was set to
    /// `false` when calling the time-of-impact function.
    pub witness_b: Vec2,

    /// The local-space outward normal on the first shape at the time of impact.
    ///
    /// This value is unreliable if `status` is
    /// [`ShapeCastStatus::PenetratingOrWithinTargetDist`] and both
    /// [`ShapeCastOptions::compute_impact_geometry_on_penetration`] was set to
    /// `false` when calling the time-of-impact function.
    pub normal_a: Vec2,

    /// The local-space outward normal on the second shape at the time of
    /// impact.
    ///
    /// This value is unreliable if `status` is
    /// [`ShapeCastStatus::PenetratingOrWithinTargetDist`] and both
    /// [`ShapeCastOptions::compute_impact_geometry_on_penetration`] was set to
    /// `false` when calling the time-of-impact function.
    pub normal_b: Vec2,

    /// The way the shape-casting algorithm terminated.
    pub status: ShapeCastStatus,
}

/// The status of the time-of-impact computation algorithm.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(C)]
pub enum ShapeCastStatus {
    /// The shape-casting algorithm ran out of iterations before achieving convergence.
    ///
    /// The content of the `ShapeCastHit` will still be a conservative approximation of the actual result so
    /// it is often fine to interpret this case as a success.
    OutOfIterations,
    /// The shape-casting algorithm converged successfully.
    Converged,
    /// Something went wrong during the shape-casting, likely due to numerical instabilities.
    ///
    /// The content of the `ShapeCastHit` will still be a conservative approximation of the actual result so
    /// it is often fine to interpret this case as a success.
    Failed,
    /// The two shape already overlap, or are separated by a distance smaller than
    /// [`ShapeCastOptions::target_distance`] at the time 0.
    ///
    /// The witness points and normals provided by the `ShapeCastHit` will have unreliable values unless
    /// [`ShapeCastOptions::compute_impact_geometry_on_penetration`] was set to `true` when calling
    /// the time-of-impact function.
    PenetratingOrWithinTargetDist,
}

/// Computes the smallest time when two shapes under translational movement are
/// separated by a distance smaller or equal to `distance`.
///
/// Returns `0.0` if the objects are touching or closer than
/// `options.target_distance`, or penetrating.
pub fn cast_shapes(
    collider_a: &Collider,
    local_to_world_a: &LocalToWorld,
    velocity_a: &Vec2,
    collider_b: &Collider,
    local_to_world_b: &LocalToWorld,
    velocity_b: &Vec2,
    options: ShapeCastOptions,
) -> Option<ShapeCastHit> {
    let mut ret = MaybeUninit::uninit();

    #[cfg(not(feature = "dynamic_wasm"))]
    let res = unsafe {
        CAST_SHAPES.unwrap_unchecked()(
            collider_a,
            local_to_world_a,
            velocity_a,
            collider_b,
            local_to_world_b,
            velocity_b,
            &options,
            &mut ret,
        )
    };

    #[cfg(feature = "dynamic_wasm")]
    let res = unsafe {
        #[derive(Copy, Clone, Debug)]
        struct Params {
            collider_a: Collider,
            local_to_world_a: LocalToWorld,
            velocity_a: Vec2,
            collider_b: Collider,
            local_to_world_b: LocalToWorld,
            velocity_b: Vec2,
            options: ShapeCastOptions,
        }

        let params = Params {
            collider_a: *collider_a,
            local_to_world_a: *local_to_world_a,
            velocity_a: *velocity_a,
            collider_b: *collider_b,
            local_to_world_b: *local_to_world_b,
            velocity_b: *velocity_b,
            options,
        };

        engine::wasm::alloc_write_and_read_external(params, &mut ret, |params, ret| {
            let params = params.cast::<u8>();

            CAST_SHAPES.unwrap_unchecked()(
                params.add(std::mem::offset_of!(Params, collider_a)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_a))
                    .cast(),
                params.add(std::mem::offset_of!(Params, velocity_a)).cast(),
                params.add(std::mem::offset_of!(Params, collider_b)).cast(),
                params
                    .add(std::mem::offset_of!(Params, local_to_world_b))
                    .cast(),
                params.add(std::mem::offset_of!(Params, velocity_b)).cast(),
                params.add(std::mem::offset_of!(Params, options)).cast(),
                ret,
            )
        })
    };

    unsafe { if res { Some(ret.assume_init()) } else { None } }
}

static mut CAST_SHAPES: Option<
    unsafe extern "C" fn(
        *const Collider,
        *const LocalToWorld,
        *const Vec2,
        *const Collider,
        *const LocalToWorld,
        *const Vec2,
        *const ShapeCastOptions,
        *mut MaybeUninit<ShapeCastHit>,
    ) -> bool,
> = None;

#[allow(clippy::missing_transmute_annotations, clippy::missing_safety_doc)]
pub unsafe fn load_module_proc_addrs(
    get_proc_addr: unsafe extern "C" fn(*const u8, *mut c_void) -> Option<NonNull<c_void>>,
    ctx: *mut c_void,
) {
    unsafe {
        CLOSEST_POINTS = transmute(get_proc_addr(
            c"physics::closest_points".as_ptr().cast(),
            ctx,
        ));
        DISTANCE = transmute(get_proc_addr(c"physics::distance".as_ptr().cast(), ctx));
        CONTACT = transmute(get_proc_addr(c"physics::contact".as_ptr().cast(), ctx));
        INTERSECTION_TEST = transmute(get_proc_addr(
            c"physics::intersection_test".as_ptr().cast(),
            ctx,
        ));
        CAST_SHAPES = transmute(get_proc_addr(c"physics::cast_shapes".as_ptr().cast(), ctx));
    }
}

#[allow(clippy::missing_safety_doc)]
pub unsafe fn set_ecs_type_id(string_id: &str, id: EcsTypeId) {
    if string_id == Collider::string_id() {
        unsafe {
            Collider::set_id(id);
        }
    } else if string_id == ColliderDebugRender::string_id() {
        unsafe {
            ColliderDebugRender::set_id(id);
        }
    }
}
