//! This crate will eventually be autogenerated (see
//! <https://github.com/bloopgames/bloop/issues/13>). It contains Rust bindings
//! for the `audio` package. Rust modules using `audio` should depend on this
//! crate, not the `audio` crate.

use std::{ffi::c_void, mem::transmute, ptr::NonNull};

use engine::{FfiStr, prelude::*};

pub fn send_event(engine: &Engine, contents: &str) {
    #[cfg(not(feature = "dynamic_wasm"))]
    unsafe {
        SEND_EVENT.unwrap_unchecked()(engine, &FfiStr::new(contents));
    }

    #[cfg(feature = "dynamic_wasm")]
    unsafe {
        engine::wasm::alloc_and_write_external_slice(contents.as_bytes(), |contents_ptr| {
            let ffi_str = FfiStr::from_raw_parts(contents_ptr, contents.len());

            engine::wasm::alloc_and_write_external(&ffi_str, |ffi_str_ptr| {
                SEND_EVENT.unwrap_unchecked()(engine, ffi_str_ptr);
            });
        });
    }
}

static mut SEND_EVENT: Option<unsafe extern "C" fn(*const Engine, *const FfiStr<'_>)> = None;

#[allow(clippy::missing_transmute_annotations, clippy::missing_safety_doc)]
pub unsafe fn load_module_proc_addrs(
    get_proc_addr: unsafe extern "C" fn(*const u8, *mut c_void) -> Option<NonNull<c_void>>,
    ctx: *mut c_void,
) {
    unsafe {
        SEND_EVENT = transmute(get_proc_addr(c"audio::send_event".as_ptr().cast(), ctx));
    }
}

#[allow(clippy::missing_safety_doc)]
pub unsafe fn set_ecs_type_id(_: &str, _: EcsTypeId) {}
